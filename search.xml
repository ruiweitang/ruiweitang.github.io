<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[demo]]></title>
    <url>%2F2019%2F02%2F14%2Fdemo%2F</url>
    <content type="text"><![CDATA[课堂测试demo 输入一个网址，浏览器会自动校验网址的格式，格式不对不能提交！ 请输入一个网址： 输入一个邮箱，浏览器会自动校验邮箱格式，格式不对不能提交请输入邮箱：选择一个日期，样式由浏览器默认实现请选择日期：输入手机号码（只有在移动端点击时会自动弹出数字输入框）请输入手机号码：输入一个数字。请输入数字：]]></content>
      <tags>
        <tag>课堂测试demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题设置方法]]></title>
    <url>%2F2019%2F01%2F25%2F2-next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下载主题：通过clone最新版本 可以通过git pull 来下载，而不用再次下载压缩包替换（我还是用下载的方法的）在站点根目录 1git clone https://github.com/iissnan/hexo -theme-next themes/next 下载压缩包 Next版本的发布页面 选择下载 Download 区域下的 Source Code (zip) 到本地 解压重命名为next，放置到themes目录下（我是使用的方法） 启用主题打开 站点配置文件 _config.yml文件， 找到 theme 字段，并将其值更改为 next 1theme: next 在切换主题之后、验证之前， 最好使用 hexo clean 来清除 Hexo 的缓存 验证主题使用hexo s 可以测试主题是否能使用 主题设置主题特性目前 NexT 目前支持四种特性，通过修改Scheme可以选择特性，比如： Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini -左侧网站信息及目录，块+片段结构布局 打开 主题配置文件 themes/next/_config.yml 文件，搜索 scheme 关键字。将你需用启用的 scheme 前面注释 # 去除即可。 12345# Schemes# scheme: Muse#scheme: Mist# scheme: Piscesscheme: Gemini 设置语言编辑 站点配置文件，将language设置成你需要的语言，我用的是简体中文： 1language: zh-Hans 目前NexT支持的语言如以下表所示： 设置菜单菜单配置包括三个部分， 第一是菜单项名称 第二是菜单项显示的文本 第三是菜单项对应的图标（NexT 使用的是 Font Awesome提供的图标） 编辑 主题配置文件，找到menu字段： 设定菜单项名称123456789101112menu: home: / || home #首页 archives: /archives/ || archive #归档 categories: /categories/ || th #分类 tags: /tags/ || tags #标签 about: /about/ || user #关于 #schedule: /schedule/ || calendar #日程表 #sitemap: /sitemap.xml || sitemap #站点地图 #commonweal: /404/ || heartbeat #公益404 # 需要哪个菜单就打开哪个菜单 # 属性值最后一个是相匹配的图标名 NexT默认的菜单项有（解注释即可显示）： 设置菜单的显示文本需要到next目录下的language/zh-Hans.yml（以简体中文为例）文件中，找到menu字段，设置如下（这一步一般是弄好的，不用管）： 12345678menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 commonweal: 公益404 设定菜单项图标 enable：控制是否显示图标，改为true则显示图标 之后的就是菜单分别使用哪个图标，可以更改，默认也可以用 12345678910menu_icons: enable: true # Icon Mapping. home: home archives: archive categories: th tags: tags about: user commonweal: heartbeat #search: search 设置侧栏修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分（我几乎没动） 是侧栏的位置， 是侧栏显示的时机 12345678910111213141516sidebar:# Sidebar Position #侧栏位置（只对Pisces | Gemini两种风格有效） position: left #靠左放置 #position: right #靠右放置# Sidebar Display #侧栏显示时机（只对Muse | Mist两种风格有效） #display: post #默认行为，在文章页面（拥有目录列表）时显示 display: always #在所有页面中都显示 #display: hide #在所有页面中都隐藏（可以手动展开） #display: remove #完全移除 offset: 12 #文章间距（只对Pisces | Gemini两种风格有效） b2t: false #返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true #返回顶部按钮的百分比 设置头像编辑 主题配置文件，修改avatar字段，值设置为头像图片的链接地址。 1avatar: http://example.com/avatar.png 也可以将图片放置到theme/source/images目录下，命名随意： 1avatar: /images/master.jpg #配置 设置作者和描述（hexo的操作中有以下内容）编辑 站点配置文件： 1234567# Sitetitle: #博客主页名字subtitle: #副标题（第二个名字）description: #描述author: #作者language: zh-Hanstimezone: #时区，可不设置 添加标签页面因为打开了菜单栏的选项，但是此时如果直接打开新添加的网页时，是打不开的显示page not found 此时需要添加对应的页面（必须通过hexo命令新建才行） 新建页面在站点的根目录中 1hexo new page tags #新建标签页面 输入命令后，在source文件夹里会生成一个tags文件夹，其中有个index.md文件。 设置页面类型修改index.md，添加type：tags 12345---title: tagsdate: 2016-11-15 19:10:05type: tags--- 然后标签页中会自动生成对应的几个标签 添加分类/关于页面和上面其实是一样的操作 123hexo new page categories/about -------------------------------------- 修改index.md文件中type类型分别为categories和about即可 在关于我页面中可以在index.md里写对应的自己的介绍 添加本地搜索功能（拓展）安装在站点根目录安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 设置编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true #true开启 此时可以在网页中使用搜索功能]]></content>
      <tags>
        <tag>操作方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo发布操作方法]]></title>
    <url>%2F2019%2F01%2F24%2F2-hexo%E5%8F%91%E5%B8%83%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[hexo操作方法（创建博客）安装步骤 npm安装的时候，默认会访问npmjs.org这个网站，国外的，把镜像地址改成了淘宝的。 修改npm镜像地址 12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 安装hexo 123npm install -g hexohexo -v # 查看hexo的版本信息 hexo操作（第一次操作需要有以下操作）初始化博客12# 新建一个目录 bloghexo init # 初始化 生成静态页面12hexo generate # 生成静态页面 hexo g # 生成静态页面（简写） 启动服务12hexo server # 启动服务hexo s # 启动服务(简写) 访问站点1http://localhost:4000/ # 通过这个地址就可以访问了 hexo常见命令 hexo n &#39;博客标题&#39;创建一篇新的博客 hexo g 生成博客 hexo d 发布博客 相关链接hexo中文文档 hexo next主题文档 hexo的next主题个性化教程:打造炫酷网站 博客内容格式设置（在md文件的最上方设置即可） 上传到git的文件是public文件夹的内容（不需要管） 自己的的md文件放到source/_posts文件夹中，注意：如果需要配置域名操作，需要在source文件夹中放CNAME文件（这个文件没有后缀名），内容写上自己的域名即可（ruiweitang.com） 123456789101112---title: 我的第一篇博客//(注意冒号后面有一个空格不能丢。)date: 2017-10-28 01:12:29 //指定博客的日期tags: - 学习 - 随笔 - 心情categories: - javascript---# 我是大标题这后面的内容就跟普通的markdown文件没什么区别 上传到git的发布配置安装hexo的部署工具npm install hexo-deployer-git --save 修改_config.yml文件 1234567891011121314151617# Sitetitle: 梦溪笔谈subtitle: description: 棠哥的测试博客keywords:author: 棠哥language: zh-CNtimezone:# 发布配置# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:ruiweitang/ruiweitang.github.io.git branch: master message: 之后的操作非常简单了（ 每次需要操作的以下几步） 把写好的md文件放到\source\_posts 文件夹中(或者直接hexo n)，md文件中的图片路径记得需要改为从根目录开始\ （**），把md文件中的图片放到images文件夹中 在总的根目录打开命令台，放好md文件之后，输入两个命令几个 hexo g：生成静态页面 hexo d：发布博客（把静态页面发送到git上）]]></content>
      <tags>
        <tag>操作方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试题讲解]]></title>
    <url>%2F2018%2F05%2F20%2F3-JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面试题1. js中使用 typeof 能得到的类型有哪些简答：undefined、string、number、boolean、object、function 就这么样就结束了吗？ 解析：1234567891011121314151617// 数据类型有哪些？// typeof 判断数据类型 把类型信息当作字符串返回 console.log(typeof undefined) //undefinedconsole.log(typeof 'abc') //stringconsole.log(typeof 123) //numberconsole.log(typeof NaN) //numberconsole.log(typeof true) //booleanconsole.log(typeof &#123;&#125;) //objectconsole.log(typeof []) //objectconsole.log(typeof null) //object(ES规范定死的)（比较地址前几位）--------------------------------console.log(typeof console.log) //functionfunction fn() &#123;&#125;console.log(typeof fn); //function// 总结： undefined/string/number/boolean/object/function 之前：六大数据类型 基本数据类型（简单数据类型） number 数值型(NaN) string 字符串 boolean 布尔型 undefined 未定义 null 空引用 引用数据类型（复杂数据类型） object 百度：1234567891011Null类型是第二个只有一个值的数据类型，这个特殊的值是null，从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值会返回“object”的原因，如下面的例子所示： var car =null; alert(typeof null); //object（其实这是JavaScript最初实现的一个错误，后来被ECMAScript沿用下来）如果定义的变量准备在将来用户保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子： if(car != null)&#123; //对car执行某些操作 &#125;实际上，undefined值是派生自null值的，因此ECMA-262规定对他们的相等测试要返回true： alert(null == undefined) //true 这里，位于null和undefined之间的相等操作符（==）总是返回true，不过要注意的是，这个操作符出于比较的目的会转换其操作数。 尽管null和undefined有这样的关系，但它们的用途完全不同，如前所述，无论什么情况下都没有必要把一个变量的值显式地设置为undefined，可视同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值。这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。 2. 何时使用 === 何时使用 ==简答：当仅需要比较值是否相等时，用==； 当需要比较类型和值时，用===。 就这么样就结束了吗？ 解析：123456789101112131415161718192021222324252627282930// 有何区别？// 会存在隐式转换。// 1.==// 如果 x 或 y 中有一个为 NaN，则返回 false；console.log(NaN == true); //false// 如果 x 与 y 皆为 null 或 undefined 中的一种类型，则返回 true（null == undefined // true）；否则返回 false（null == 0 // false）；console.log(null == undefined); //true(特殊情况)---------------------------------console.log(null == ''); //falseconsole.log(undefined == ''); //false// 如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 Number 函数转化为 Number 类型再进行比较；console.log(true == '123'); //falseconsole.log(true == '1'); //trueconsole.log(false == '0'); //trueconsole.log(true == !0); //trueconsole.log([] == []); //falseconsole.log([] == ![]); //true 比较地址 ------------------------------------------------var a = c = [];var b = [];console.log(a == b); //falseconsole.log(a == !b); //trueconsole.log(a == c); //trueconsole.log(Boolean([]) == true); //trueconsole.log(Number([]) == 0); //trueconsole.log(Number(false) == 0); //true ####百度： 123如果 x 或 y 中有一个为 NaN，则返回 false；如果 x 与 y 皆为 null 或 undefined 中的一种类型，则返回 true（null == undefined // true）；否则返回 false（null == 0 // false）；如果 x,y 类型不一致，且 x,y 为 String、Number、Boolean 中的某一类型，则将 x,y 使用 Number 函数转化为 Number 类型再进行比较； 3. js变量按照存储方式分为哪些类型，并描述其特点简答：简单数据类型、复杂数据类型（值、引用）。 值类型：简单类型， 变量在存储简单类型的时候，存储的是值本身。 引用类型：复杂类型，变量在存储复杂类型的时候，只会存储这个对象的地址，并不会存储对象的值。 ？？？ 解析：123456789101112131415161718192021222324252627//简单类型(值类型)//复杂类型(引用类型)//在内存中如何存储 （内存） 内存（2G 4G 8G 16G） 硬盘空间（）//简单类型如何存储//变量在存储简单类型的时候，存储的直接就是值本身。var num = 11;var num2 = num;num2 = 22;console.log(num); //11console.log(num2); //22//变量在存储复杂类型的时候，不会把整个对象都存储起来，只会存这个对象的地址（引用）//对象会在内存中随机找一块内存存储起来.var obj = &#123; name: "zs", age: 18&#125;;var obj2 = obj; //把obj的值赋值给obj2（地址）obj2.name = "ls";console.log(obj.name); //lsconsole.log(obj2.name); //ls//值类型：简单类型， 因为变量在存储简单类型的时候，存储的是值本身。//引用类型：复杂类型，变量在存储复杂类型的时候，只会存储这个对象的地址，并不会存储对象的值。var obj = &#123;&#125;;var obj2 = obj; //仅仅是地址赋值了一份，所以两个变量都指向了同一个地址。 4. 数组的常用api有哪些简答：push() 、pop() 、unshift() 、shift()；es6：filter()、 forEach()、 some() 、every() 、map()等 ？？？ 解析：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// push() pop() unshift() shift()// es6：filter() forEach() some() every() map()等// 注意// 1. forEach存在的问题，循环停不下来// 2. filter、map 方法的使用var arr = [12, 34, 56, 89, 78, 23, 45, 19];//filter方法返回一个由符合函数要求的元素组成的新数组-------------------------------------------// 1. 要求：把arr中所有大于30的元素放到一个新数组中。// 原始方法：var newArr = [];for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 30) &#123; newArr.push(arr[i]) &#125;&#125;// API的方法：//调用数组的filter方法，添加过滤方法，符合规则的元素会被存放到新数组里//element:表示数组里的元素;index:表示索引值;array:表示调用filter方法的数组。var newArr = arr.filter(function (element, index, array) &#123; return element &gt; 30;&#125;);console.log(arr); //filter方法不会改变原数组里的数据[12,34,56,89,78,23,45,19];console.log(newArr); //新数组里保存符合要求的元素[34, 56, 89, 78, 45]//map方法让数组中的每个元素都调用一次提供的函数，将调用的后的结果存放到一个新数组里并返回。------------// 2. 要求：件数组中的每一个元素后面添加一个字符串'0'放到一个新数组中。// 原始方法var newArr = [];for (var i = 0; i &lt; arr.length; i++) &#123; newArr.push(arr[i] + '0');&#125;// API的方法var newArr = arr.map(function (element, index, array) &#123; //在数组里的每一个元素的最后面都添加一个字符串"0" return element + "0";&#125;);console.log(newArr); //["120", "340", "560", "890", "780", "230", "450", "190"]console.log(arr); //map方法不会改变原数组里的数据 [12,34,56,89,78,23,45,19]//forEach() 方法对数组的每个元素执行一次提供的函数,且这个函数没有返回值------------------------------// 3.要求：打印每一个元素// 原始方法for (var i = 0; i &lt; arr.length; i++) &#123; console.log("第" + i + "个元素是" + arr[i]);&#125;// API方法var result = arr.forEach(function (element, index, array) &#123; //数组里的每一个元素都会被打印 console.log("第" + index + "个元素是" + element);&#125;);console.log(result); //函数没有返回值//some() 方法测试数组中的某些元素是否通过由提供的函数实现的测试.----------------------------------// 4.要求：判断数组中是否有元素大于50// 原始方法for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &gt; 50) &#123; result = true; break; &#125;&#125;// API方法var result = arr.some(function (element, index, array) &#123; //数组里否有一些元素大于50.只要有一个元素大于，就返回true console.log(element); //12,34,56 return element &gt; 50;&#125;);console.log(result); //true//every() 方法测试数组的所有元素是否都通过了指定函数的测试。----------------------------------------// 5.要求：判断数组中的每个元素是否都大于50// 原始方法var result = true;for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; 50) &#123; result = false; break; &#125;&#125;// API方法result = arr.every(function (element, index, array) &#123; //数组里是否每一个元素都大于50.只有在所有的数都大于50时，才返回true console.log(element); return element &gt; 50;&#125;);console.log(result); //false 5. 如何准确判断一个变量是数组类型简答：可以通过 instanceof 来判断， 用arr instanceof Array; 。 ？？？ 解析：123456789// instanceof 操作符// 用来判断引用数据类型属于哪个构造函数的方法// f instanceof Foo 的判断逻辑：构造函数的原型对象，是否在实例对象的原型链上// Foo.prototype 是否在 实例f的原型链上var arr = [];arr instanceof Array; // truetypeof arr; // object,, typeof 只能获取简单数据的类型 之前：js基础阶段对instanceof作用的描述 : 判断一个对象是否是某个构造函数的实例 现在我们学习了原型,也学习了原型链,所以我们现在可以更严谨的描述他的作用: 判断一个函数的原型对象,是否在实例对象的原型链上 6. 描述 new 一个对象的过程简答：12341. 创建一个对象；2. this 指向这个新创建的对象；3. 执行构造函数的代码；4. 返回this。 ？？？（这次还说吗？） 7. 说一下变量提升的理解?简答： 变量定义、函数声明提升（同名提升问题） 因为在es6之前没有块级作用域，早起提出一个预解析的方案，但是实际使用的时候，并没有想的那么好。 es6中的let和const可以拥有块级作用域。 解析： 声明提升 1234567891011121314151617181920212223242526272829303132// 1.变量提升var a;console.log(a); // undefinedvar a = 100;// 2.函数声明提升function fn(name)&#123; var name='zs'; var age; age = 20; console.log(name, age); //zs 、20&#125;fn('zs');//3.变量与函数function a() &#123; console.log('我是函数');&#125;console.log(a);var a = 10;console.log(a);// 声明提升的范围：全局作用域 &amp;&amp; 函数内部// 注意：函数声明和函数表达式的区别var a;console.log(a);var a=10;var a=function()&#123; console.log('我是函数');&#125;console.log(a); 作用域（es6中的let和const） 1234567891011121314151617181920212223242526//es6之前// 没有块级作用域&#123;&#125;，只有全局作用域和函数作用域（词法作用域）// 无块级作用域(如果有块级作用域)console.log(a); // undefined --&gt; 没有块级作用域，变量提升到全局作用域if(true)&#123; var a = 'zs'; // 提升到if外面（如果是let呢）&#125;console.log(a); // zs// 函数作用域和全局作用域var a = 100;function fn()&#123; var a = 200; console.log('fn ',a); // 200&#125;console.log('global ',a); // 100fn();// 作用域链// 作用域链是在函数定义的时候确定下来的var a = 100;function fn()&#123; var b = 200; console.log(a); // 100 --&gt; 当前作用域没有声明变量a，去声明时父级作用域中取值 console.log(b); // 200&#125; 8. 说明 this 几种不同的使用场景?简答：构造函数（new出来的过程）、对象方法、普通函数、借用方法模式（上下文调用模式） 解析：123456789101112131415161718192021222324252627282930313233343536373839404142434445// this的指向要在函数执行的时候才能确定，函数定义时是无法确认（就是只看函数是如何被调用的，而不看函数是如何定义的）// 1. 作为普通函数执行function fn()&#123; console.log(this === window);&#125;fn(); // true// 2. 对象调用模式var obj = &#123; name: 'A', printName: function()&#123; console.log(this.name) &#125;&#125;;obj.printName(); // A// 3. 构造函数new的时候（this指向的变化）function Foo(name)&#123; this.name = name; console.log(this);&#125;var f = new Foo('zs');// f// 4. 借用方法（上下文调用模式）function fn(name)&#123; console.log(name); console.log(this);&#125;fn.call(&#123;x:100&#125;, 'zs');// zs// &#123;x:100&#125;// 综合：var a = &#123; name: 'A', fn: function()&#123; console.log(this); &#125;&#125;;a.fn(); // ？？a.fn.call(&#123;name: 'B'&#125;); // B --&gt; fn函数内部的this指向&#123;name: 'B'&#125;var fn2 = a.fn;fn2(); // fn2函数内部的this指向window，不看函数是如何定义的，只看函数是如何被调用的 9. 如何理解作用域?简答： es6之前的作用域只有全局作用域和函数作用域（词法作用域） es6出现了块级作用域（{}） 作用域出现是历史原因 解析：1234567891011121314151617181920212223242526//es6之前// 没有块级作用域，只有全局作用域和函数作用域（词法作用域）// 无块级作用域(如果有块级作用域)console.log(a); // undefined --&gt; 没有块级作用域，变量提升到全局作用域if(true)&#123; var a = 'zs'; // 提升到if外面&#125;console.log(a); // zs// 函数作用域和全局作用域var a = 100;function fn()&#123; var a = 200; console.log('fn ',a); // 200&#125;console.log('global ',a); // 100fn();// 作用域链// 作用域链是在函数定义的时候确定下来的var a = 100;function fn()&#123; var b = 200; console.log(a); // 100 --&gt; 当前作用域没有声明变量a，去声明时父级作用域中取值 console.log(b); // 200&#125; 10. 实际开发中闭包的应用?简答： 私有化数据。 数据保持。 解析：1234567891011121314151617function main()&#123; var money = 10000; //放到局部作用中,防止全局变量污染(私有化数据) return &#123; queryMoney : function()&#123; return money; &#125;, payMoney : function(num)&#123; money -= num; &#125;, addMoney : function(num)&#123; money += num; &#125; &#125;&#125;var moneyManger = main(); // 通过moneyManger 可以获取到局部的变量money 缺点： 由于内部的函数使用了外部函数的变量,导致外部这个函数无法被回收掉.如果代码中大量的存在闭包,可能会导致内存泄露 (不要刻意使用闭包)。 笔试题1.打印结果是什么？123456789101112console.log(1);setTimeout(function()&#123; console.log(2);&#125;, 0);console.log(3);setTimeout(function()&#123; console.log(4);&#125;, 1000);console.log(5);// print: ？？？堆栈。。。 2. 打印结果是什么？123456789function add(x, y) &#123; console.log(x + y);&#125;function sub(x, y) &#123; console.log(x - y)&#125;add.call(sub, 5, 3);// 打印些什么 3.打印结果是什么？1234567891011121314151617181920// 1. (function(foo)&#123; console.log(foo.bar); // 返回结果？？？&#125;)(&#123; foo: &#123; bar: 1 &#125; &#125;);// 2.(function f(f)&#123; console.log(f()); // 返回结果？？？&#125;)(function()&#123; return 1; &#125;);// 3.var foo = &#123; bar: function() &#123; return this; &#125;, baz: 1&#125;;(function()&#123; console.log(arguments[0]()); // 返回结果？？？&#125;)(foo.bar); ##4. 结果是什么？ 123456789101112131415161718192021// 1、考察原型链// 下面程序执行后弹出什么样的结果?function fn() &#123; this.a = 0; this.b = function() &#123; alert(this.a) &#125;&#125;fn.prototype = &#123; b: function() &#123; this.a = 20; alert(this.a); &#125;, c: function() &#123; this.a = 30; alert(this.a); &#125;&#125;var myfn = new fn();myfn.b(); // ???myfn.c(); // ??? 5. 统计一个字符串中每个字符出现的次数123456789101112var str = 'asdfssaaasasasasaa';var arr = str.split('');var result = &#123;&#125;;arr.forEach(function (e, i, a) &#123; if (result[e] == undefined) &#123; result[e] = 1; &#125; else &#123; result[e]++; &#125;&#125;)console.log(result); 6. 获取随机数，要求是长度一致的字符串格式1234567891011// Math.random() 生成[0,1)的随机数，小数点后面数值个数不定function getRanLeng()&#123; // 要求是每次获取的长度是一致的 // 所以可以在随机数后面加上一定位数的字符串的00000 防止生成的是1位数，务必多余9位，越多越好 var random = Math.random() + '0000000000'; return random.slice(0, 10);&#125;for(var i = 0; i &lt; 100; i++)&#123; console.log(getRanLeng())&#125; 7. 去掉一个数组的重复元素123456789var arr = [1, 2, 3, 1, 43, 12, 12, 1, 2, 3, 4, 5];var result=[];for (var i=0;i&lt;arr.length;i++)&#123; if(result.indexOf(arr[i])==-1)&#123; result.push(arr[i]); &#125;&#125;console.log(result) 8. 完成下列要求,函数返回扁平化后的数组如：[1, [2, [ [3, 4], 5], 6]] =&gt; [1, 2, 3, 4, 5, 6]。123456789101112131415var arr = [1, [2, [ [3, 4], 5], 6]];//用了什么方法？用了什么语法？不要纠结语法，但是要会说。var newArr=[];function fn() &#123; for(var i=0;i&lt;arguments.length;i++)&#123; if(arguments[i] instanceof Array)&#123; fn.apply(null,arguments[i]); &#125;else&#123; newArr.push(arguments[i]); &#125; &#125;&#125;fn.apply(null,arr);console.log(newArr); 9.求数组中：最小的x坐标、最大的y坐标12345678910111213141516171819202122var arr = [ [1, 2], [22, 55], [66, 99], [-11, -100], [88, 22], [101, 89], [99, 98], [21, 77]]//要求：求数组中 最小的x坐标 最大的y坐标// forEach map some every filter// map会返回一个新数组var min = Math.min.apply(null, arr.map(function (e) &#123; return e[0]&#125;));var max = Math.max.apply(null, arr.map(function (e) &#123; return e[1]; //以为是每一项的第二个才是y&#125;));console.log(min,max); 拓展容易错的面试题]]></content>
      <tags>
        <tag>授课笔记简略版</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git学习笔记]]></title>
    <url>%2F2018%2F05%2F05%2F3-git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[学习目的 在实际工作开发中，并不是一个人敲代码，需要团队的协作，用版本控制工具会提高我们程序员的项目开发效率。所以目的之一就是让大家在初次搭建项目的时候就能熟悉以后工作时候的环境，培养一个好的团队合作习惯。 自己项目可以试着推送到自己的git上，算是自己成长的积累。 面试有的时候会要求在git上有自己的作品，有自己的项目。作为一个有多年工作经验的程序员，很多都会在git上传自己的作品。 学习要求 了解git是什么？ 使用git的作用是什么？ 会使用常用的git命令。 能将自己写的项目推到远程仓库中。 git的安装注意：1. 不要安装在中文目录 ：以后安装软件都要注意这一点，很多软件安装路径存在中文会出错。 ​ 2. 不要使用桌面管理软件：使用桌面管理软件以后，右键出现的菜单会被管理，会隐藏我们要使用的功能按钮。 安装很简单，一直下一步即可。在任意的目录下右键，能够出现 Git GUI Here 和 Git Bash Here ，表示安装成功了。 例子 当我们做甲项目时，做到了一半。 此时Boss说你手头的项目先停一停，先做乙项目，马上要上线了，此时你停下手头的事开始做乙项目。 当乙项目做到一半的时候，Boss又说你做甲项目去吧，乙项目延后了，这时候你又去做甲项目了。 但是甲项目已经被你同事做了一大半了，此时你很高兴，然后接着往后做。（你们此时怎么配合） 当甲项目做了一大半的时候，万恶项目经理说你们做的不好，要你从你之前写到一半的地方重新写。（你怎么办） 当你甲项目改了到一大半的时候，此时万恶的产品经理又说客户的需求改了，之前写的就很好，要你复原之前的项目（。。。） 。。。。。。。。 告辞！（我要删库！！）（项目经理怎么办） 在实例开发过程中，与团队的配合协作往往会花很多的时间与经历，并且每一次手动保存很耗时间和精力，为了将我们的精力都用在开发上，现在公司开发项目都会用到版本控制工具。 为什么要有版本控制系统？ 在开发过程中，经常需要对一个文件进行修改甚至删除，但是我们又希望能够保存这个文件的历史记录，如果通过备份，那么管理起来会非常的复杂和繁琐。 在多人开发时，如果需要多人合作开发一个页面，那么修改以及合并也会非常的棘手。容易出现冲突。 ##什么是版本控制系统？ 版本控制系统（Version Control System）:是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。 常见的版本控制系统有：cvs、svn、git 版本控制系统的分类本地版本控制系统本地版本控制系统就是在一台机器上，记录版本的不同变化，保证内容不会丢失。 缺点：如果多人开发，每个人都在不同的系统和电脑上开发，没办法协同工作。 集中式版本控制系统svn/cvs都是集中式的版本控制系统。 需要一个中央服务器来管理代码的的版本和备份。 所有的用户电脑都是从中央服务器获取代码或者是将本地的代码提交到中央服务器。 依赖与网络环境，如果连不上中央服务器，就无法提交和获取代码。 如果中央服务器宕机，所有人都无法工作。 分布式版本控制系统git是分布式的版本控制系统。 需要一台服务器作为代码仓库。 每个用户电脑都是一个服务器（代码仓库），并且和代码仓库是镜像的，用户修改和获取代码都是提交到自己的服务器当中。 不需要网络就可以进行工作。 当连接网络时，用户可以选择将自己的服务器与代码仓库进行同步。 git介绍 Git是一款免费、开源的分布式 版本控制系统 ，用于敏捷高效地处理任何或小或大的项目。 Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 git的使用方式 git是用法方式主要有两种。 git gui，即图形化界面的方式。 git bash，（cmi）命令行的方式。 给window用户的忠告：git的命令必须使用linux风格的shell来运行Git命令，不能使用window风格的shell运行git命令 在任意文件夹中，都可以使用右键，通过git bash here打开命令行窗口，此时的路径就是当前目录。 窗口上右键，通过options–&gt;Text–&gt;select可以调整字体的大小。 bash入门（了解）bash是许多linux系统默认的shell(命令行工具)。 cmd和powershell是window系统默认的shell(命令行工具)。 二者的功能都一样，通过命令行来操作计算机的功能。 为什么要学习bash？ 必须使用linux风格的shell来运行git命令 工作过程中，项目都是部署在linux系统中，了解一些常用的bash命令也是有必要的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# cd 改变目录 （change directory）cd images #进入images文件夹cd .. #进入上一层目录cd ~ #进入用户根目录# tab 自动补全，当我们输命令或者目录很长时，可以使用tab键进行自动补全。# 按两次tab，会把所有符合要求的内容都列出来。# pwd 打印当前目录的路径 （print work directory）pwd# ls 展示当前目录列表（list）ls # 展示当前目录ls -a # 展示全部内容，包括隐藏文件ls -l # 以列表的形式展示内容# clear reset清屏clear # 清除屏幕内容，滚动条，保留了历史reset # 重置，历史记录没了。# mkdir 创建一个文件夹 （make directory）mkdir css # 创建一个css的文件夹mkdir css img js # 创建了三个文件夹# rmdir 删除一个空的文件夹（没啥用）rmdir img # 删除文件夹# touch 创建文件touch index.html #创建了一个index.html文件touch css/index.css # 在css目录下创建idnex.css文件# rm 删除一个文件获取文件夹rm index.html # 删除index.html文件rm -r css # 递归删除一个文件夹# mv 移动文件（move）mv index.html js # 将html文件移动到js文件夹中mv index.html index2.html # 将index.html重命名为index2.html# cp 复制文件（cp）cp index.html index2.html # 复制index.html文件，命名为index2.htmlcp -r css css02 # 如果复制的是文件夹，需要使用-r参数。# cat 查看文件全部内容cat index.html 试一试： 在桌面新建一个 test文件夹 在test文件夹中打开git命令窗口 创建 css images js 三个文件夹 新建index.html文件，在css文件中新建index.css文件， 在images中新建index.png文件，在js文件中新建index.js 把index.html重命名为index2.html 把index.css文件挪到js文件中 git初体验在第一次使用的时候，需要配置你的用户邮箱和用户名称，这两条配置是很重要的，每次提交git代码都会引用这两条信息，记录了谁提交了代码，会永久的记录在历史记录中。 123456789# git config user.name 你的目标用户名# git config user.email 你的目标邮箱名# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。git config --global user.name rwtgit config --global user.email 1219984262@qq.com# 查看配置信息git config --list 初始化git仓库git init 查看当前git仓库的状态git status 将文件添加到git的暂存区git add 文件名 将文件由暂存区提交到仓库区git commit -m &#39;提交说明&#39; 查看提交日子git log 1234567891011121314151617# 要对某个项目使用git进行管理，需要使用git init命令初始化git仓库# 会在当前目录生成一个隐藏文件夹 .git 不要去修改这个文件夹下的任意东西。git init# 查看git文件的状态 ,如果此时新建一个文件，那么这个文件是没有被追踪的，说白了git还没有管理这个新建的文件git status # 告诉git开始对index.html文件进行追踪， git会在暂存区中存储这个文件git add index.html# 让文件由暂存区提交到仓库区。此时文件才真正的被git管理了。# 如果提交日志乱码，右键--&gt;options--&gt;Text--&gt;将编码改成utf-8git commit -m '第一次提交'# 查看提交日志git log git的三个区工作区、暂存区、本地仓库区 工作区：我们书写代码的地方，工作的目录就叫工作区。 暂存区：使用add命令，在.git目录中的一个索引文件，记录修改的文件 本地仓库区：将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。 git命令详解git add(重点) 作用：让git追踪一个新的文件，并且将文件由 工作区 添加到 暂存区，暂存文件 命令：git add 文件名/目录名 例如： git add index.html git add --all 或者 git add -A 获取git add .（简写） 添加所有文件 git add a.txt b.txt 同时添加两个文件 git add *.js 添加当前目录下的所有js文件 git add css/添加css目录下所有的文件 git checkout 文件名 作用：暂存区的内容恢复到工作区。 git checkout 1.txt 将暂存区中1.txt文件恢复到工作区 git commit（重点） 作用：将文件由 暂存区 添加到 仓库区，生成版本号（历史记录，以后可以回退到某一个版本号） git commit -m &quot;提交说明&quot; git status 作用：查看文件的状态 命令：git status 命令：git stauts -s 简化日志输出格式 git log 作用：查看提交日志 git log 只能查看当前head以及以前的日志 git log --oneline 简洁的日志信息,如果提交的日志非常多了 git reflog 查看所有的提交变更日志 git reset 作用：版本回退，将代码恢复到已经提交的某一个版本中。 git reset --hard 版本号 将代码回退到某个指定的版本(版本号只要有前几位即可) git reset --hard head~1将版本回退到上一次提交 ~1:上一次提交 ~2:上上次提交 ~0:当前提交 远程仓库所有的程序员都可以通过远程仓库来进行版本的共享，达到所有人的代码一致的效果。 githubgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，是git的一个远程代码仓库。 将来工作时，公司会有自己的代码仓库。 github官网 开源中国-git 121. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。 在github上创建一个项目，获取到仓库的地址。然后就可以将本地的代码推送到远程的服务器上。 注册步骤： 打开github官网： 填写信息，进行注册： 登录： 远程仓库相关命令git push 作用：将本地仓库中代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 例子：git push https://github.com/ruiweitang/gitStudy.git master 如果第一次使用，需要填写github的用户名和密码 在git push之前，先git pull: 保证先把远程仓库代码先拉取到本地 git pull 作用：将远程的代码下载到本地 git pull 代码地址 master 将远程的代码中master分支下载到本地 通常在push前，需要先pull一次。 git clone 作用：克隆远程仓库的代码到本地 git clone [远程仓库地址] git clone https://github.com/ruiweitang/gitStudy.git会在本地新建一个gitStudy文件夹，在gitStudy中包含了一个.git目录，用于保存所有的版本记录，同时gitStudy文件中还有最新的代码，你可以直接进行后续的开发和使用。 git克隆默认会使用远程仓库的项目名字，也可以自己指定。需要是使用以下命令：git clone [远程仓库地址] [本地项目名]（gitStudy-&gt;自己想要的名字） git remote每次push和pull操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 git remote add 仓库别名 仓库地址 使用仓库别名替代仓库地址。仓库别名相当于一个js变量，仓库地址就是对应的值。 git remote add rwt https://github.com/ruiweitang/gitStudy.git 设置了一个rwt的仓库别名，以后push和pull都可以不用仓库地址，而用rwt，origin git remote remove rwt 删除rwt这个仓库别名。 git remote 查看所有的仓库别名 如果使用了git clone命令从远程仓库获取下来的，那么这个本地仓库会自动添加一个 origin的远程地址，指向的就是克隆的远程地址。 SSH免密码登录git支持多种数据传输协议： https协议：https://github.com/ruiweitang/gitStudy.git 需要输入用户名和密码 ssh协议：`git@github.com:ruiweitang/gitStudy.git` 可以配置免密码登录 每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码 SSH免密码登录配置注意：这些命令需要在bash中敲 创建SSH Key：ssh-keygen -t rsa 在文件路径 C:\用户\当前用户名\ 找到 .ssh 文件夹 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 粘贴 公钥 id_rsa.pub 内容到对应文本框中 在github中新建仓库或者使用现在仓库，拿到`git@github.com:用户名/仓库名.git` 此后，再次SSH方式与github“通信”，不用输入密码确认身份了]]></content>
      <tags>
        <tag>操作方法</tag>
        <tag>授课笔记简略版</tag>
      </tags>
  </entry>
</search>
